{
  "hash": "302424900a7ebe14780f0076a138f8ec",
  "result": {
    "markdown": "---\nexecute: \n  eval: false\n---\n\n<!--\nthis is placeholder text\n**fett**\n*kursiv*\n[Homepage](https://alexfelker12.github.io/dst-documentation-af108/ 'Zurück zur Homepage')\n-->\n\n# Erstellungsprozess\n\n## Planung\n\nAus diversen Modulen in meinem Studium hatte ich die Wichtigkeit einer guten Planung für den Erfolg eines Projekts als lehrreichste Erfahrung mitgenommen. Teilweise halte ich die Planung für einige Projekte in meinem Studium jedoch immer noch ein wenig zu klein und kurzsichtig, was sich im Nachhinein immer als Ärgernis darstellt.\n\nIn diesem Modul hatte ich für die Planung und der schier Unmengen an Möglichkeiten zur Analyse des Datensatzes nach einer Methode Ausschau gehalten, mit denen ich verschiedene Auffälligkeiten im Datensatz schnell entdecken und untersuchen kann. Dabei hatte ich von der Homework mit Streamlit die Idee, Tabellen interaktiv mit der Auswahl von Attributen für die X- und Y-Achse zu erstellen und diese mit verschiedenen Aggregationen und Sortierungen zu kombinieren, wodurch ich zwei Attribute schnell und mit der Leichtigkeit von ein paar Klicks näher untersuchen konnte. Vieles fand aber in einigen Jupyter Notebooks statt, bei dem ich verschiedene Visualisierungen mit Altair getestet habe, um für jede Information, die ich präsentieren will, den passenden Graphtypen zu finden.\n\n## Umsetzung\n\nUm dies umzusetzen habe ich eine Funktion gebraucht, die all diese Parameter nehmen kann und mir einen Altair Chart returned. Mithilfe von ChatGPT und einigen korrigierenden Prompts habe ich diese Funktion schließlich erstellen können:\n\n::: {style=\"padding-bottom: 20px;\"}\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ndef create_chart(df, x='', y='', aggregation='sum', chart_type='bar', title='', sort_order=None, show_text=False):\n    \"\"\"\n    Create a chart based on the specified parameters.\n\n    Parameters:\n        - df: DataFrame, the input DataFrame.\n        - x: str, the column for the x-axis.\n        - y: str, the column for the y-axis.\n        - aggregation: str, the aggregation method ('average', 'sum', 'count', 'min', 'max', 'median', 'stdev', 'variance').\n        - chart_type: str, the type of chart ('bar', 'point', 'line', 'area', 'tick', 'scatter', 'boxplot').\n        - title: str, the title of the chart.\n        - sort_order: str, the sort order for the x-axis ('ascending', 'descending', None).\n        - boxplot: bool, whether to create a boxplot.\n\n    Returns:\n        - alt.Chart: Altair chart object.\n    \"\"\"\n\n    title = f'{aggregation.capitalize()} of {y} by {x}' if title == '' else title\n\n    valid_aggregations = ['', 'average', 'sum', 'count',\n                          'min', 'max', 'median', 'stdev', 'variance']\n    valid_chart_types = ['bar', 'point', 'line',\n                         'area', 'tick', 'scatter', 'boxplot']\n    valid_dtypes = ['int64', 'float64', 'category']\n\n    if aggregation not in valid_aggregations:\n        raise ValueError(\n            f\"Invalid aggregation method. Choose one of {valid_aggregations}.\")\n\n    if chart_type not in valid_chart_types:\n        raise ValueError(\n            f\"Invalid chart type. Choose one of {valid_chart_types}.\")\n\n    if df[x].dtype not in valid_dtypes:\n        raise ValueError(\n            f\"Invalid data type for x. Has to be one of {valid_dtypes}.\")\n\n    chart_type_mapping = {\n        'bar': alt.Chart(df).mark_bar(),\n        'point': alt.Chart(df).mark_point(),\n        'line': alt.Chart(df.sort_values(by=[x])).mark_line(),\n        'area': alt.Chart(df).mark_area(),\n        'tick': alt.Chart(df).mark_tick(),\n        'scatter': alt.Chart(df).mark_circle(),\n        'boxplot': alt.Chart(df).mark_boxplot()\n    }\n\n    x_enc = f'{x}:O' if df[x].dtype == 'category' else f'{x}:Q'\n    boxplot_y_enc = f'{y}:Q'\n    y_enc = f'{aggregation}({y}):Q' if aggregation else f'{y}:O' if df[\n        y].dtype == 'category' else f'{y}:Q'\n\n    if chart_type == 'boxplot':\n        return chart_type_mapping['boxplot'].encode(\n            x=alt.X(x_enc, sort='y' if sort_order ==\n                    'ascending' else '-y' if sort_order == 'descending' else None),\n            y=alt.Y(boxplot_y_enc),\n            color=x_enc,\n            tooltip=[x_enc, y_enc],\n        ).properties(\n            title=title\n        )\n    else:\n        chart = chart_type_mapping[chart_type].encode(\n            x=alt.X(x_enc, sort='y' if sort_order ==\n                    'ascending' else '-y' if sort_order == 'descending' else None),\n            y=alt.Y(y_enc),\n            color=x_enc,\n        )\n\n        text_labels = alt.Chart(df).mark_text(\n            align='center',\n            baseline='bottom',\n            dx=0,\n            fontSize=14,\n        ).encode(\n            x=alt.X(x_enc, sort='y' if sort_order ==\n                    'ascending' else '-y' if sort_order == 'descending' else None),\n            y=alt.Y(y_enc),\n            text=alt.Text(y_enc, format='.2f'),\n            opacity=alt.value(1) if show_text else alt.value(0),\n        )\n\n        return (chart + text_labels).properties(\n            title=title,\n            width='container'\n        )\n```\n:::\n\n\n:::\n\n::: {style=\"padding-bottom: 30px;\"}\n\nDies funktioniert allgemein so, dass anhand des übergebenen Chart Typs die passende Altair Chart Funktion benutzt wird und aufbauend auf diesem das Encoding und die Properties basierend auf den anderen übergeben Parameter hinzugefügt werden.\n\nMithilfe dieser Funktion konnte ich eine Vielzahl verschiedener Graphen erstellen, die mir geholfen haben, die Daten besser zu verstehen. Auch wenn man nicht jeden Graphen mit dieser Funktion visualisieren kann, war sie meiner Meinung nach hilfreich und informativ genug, sodass ich mich entschieden habe, diese Funktion in meinem Dashboard für die spielerische Nutzung zu integrieren, bzw. drinnen zu lassen.\n\n:::\n\nFür die RevealJS Präsentation und dem Streamlit Dashbaord habe ich noch zwei weitere Graphen erstellt und diese ähnlich wie die erste in einer Funktion zum einfachen Aufrufen verpackt.\nEin Graph war die Länderkarte, welche man mit der `create_chart()` Funktion nicht ohne weiteres erstellen konnte. Hierzu habe ich dann, ebenfalls mit der Hilfe von ChatGPT, diese Funktion erstellt (verkürzt, Error-Handling, Chart-Mapping und x-/y-encoding genau wie bei `create_chart()`):\n\n::: {style=\"padding-bottom: 20px;\"}\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef create_map_chart(df=df, mark_column='', sel_locs=[], aggregation='sum', marker_type='point', title=''):\n    \n    # ...\n    # US states background\n    states = alt.topo_feature(data.us_10m.url, 'states')\n    background = alt.Chart(states).mark_geoshape(\n        fill='lightgray',\n        stroke='white',\n    ).encode(\n        tooltip=alt.value(None)\n    ).properties(\n        title=title,\n    ).project('albersUsa')\n\n    # data points\n    points = marker_type_mapping[marker_type].encode(\n        longitude='Longitude:Q',\n        latitude='Latitude:Q',\n        size=alt.Size(c_enc, title=title),\n        color='Location:N',\n        tooltip=['Location:N', alt.Tooltip(c_enc, format='.2f')],\n    ).interactive()\n\n    # selected states\n    text_labels = alt.Chart(filtered_df).mark_text(dx=0, dy=-13, color='black').encode(\n        longitude='Longitude:Q',\n        latitude='Latitude:Q',\n        text=alt.Text(f'{c_enc}', format='.2f'),\n        tooltip=alt.value(None)\n    )\n\n    final_map_chart = background + points + text_labels\n    return final_map_chart\n```\n:::\n\n\n:::\n\n::: {style=\"padding-bottom: 30px;\"}\n\nDiese Funktion funktioniert ähnlich wie die `create_chart()` Funktion nur, dass diese Funktion ein Altair Chart returned, welches aus drei Schichten besteht. Die Karte ist der lediglich der Hintergrund (Staatsgrenzen), während die Punkte innerhalb der einzelnen Staaten der eigentliche informative Graph sind. Diese Funktion funktioniert ausschließlich für Chart Maps.\n\n:::\n\nDie andere Funktion war die „create_subscription_grouped_chart“, welche einen gruppierten Bar Chart erstellt. Dieser Chart wurde auch nur einmal aufgezeigt, weshalb es hier für einen geringeren Aufwand keine Parameter für Variationen gab. Der Grouped Chart hatte die Aufgabe, aufzuzeigen, wie sich die genutzten Discounts auf die Kunden mit und ohne Subscription (oder Premium Status) verteilen:\n\n::: {style=\"padding-bottom: 20px;\"}\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef create_subscription_grouped_chart():\n    grouped_df = df.groupby(['Subscription Status', 'Discount Applied'], observed=True)[\n        'Purchase Amount (USD)'].sum().reset_index()\n\n    sp_chart = alt.Chart(grouped_df).mark_bar().encode(\n        x='Discount Applied:N',\n        y='sum(Purchase Amount (USD)):Q',\n        color='Subscription Status:N',\n        tooltip=['Subscription Status:N', 'Discount Applied:N',\n                 'sum(Purchase Amount (USD)):Q']\n    ).properties(\n        width='container',\n        title='Sum of Purchase Amount (USD) per Subscription Status by Discount Applied'\n    )\n\n    return sp_chart\n```\n:::\n\n\n:::\n\n\n## RevealJS Aufbau\n\nMithilfe dieser drei Funktionen war ich in der Lage die RevealJS Präsentation und das Streamlit Dashboard aufzubauen. Dadurch, dass die Graphen anhand der in die jeweiligen Funktion übergebene Parameter aufgebaut und individualisiert werden, konnten sie für statische als auch dynamische Darstellungen der Graphen benutzt werden. Aufgrund dessen konnte ich sowohl bei der Quarto Präsentation als auch beim Streamlit Dashboard diese Funktionen gleichermaßen nutzen und musste nur die Parameter anpassen. \nDurch die Quarto Markdown Syntax und CSS Style-Rules konnte ich das Layout einer Slide in der Basis so aufbauen:\n\n::: {style=\"padding-bottom: 20px;\"}\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ncreate_chart(df=df, x='Subscription Status', y='Previous Purchases',\n             aggregation='average', chart_type='bar', show_text=True)\n\n```\n:::\n\n\n:::\n\n\nBei einigen Slides waren noch einige Text und andere Visualisierungselemente enthalten die ich einfach mit dem aus der `create_chart()` Funktion erstellten Chart kombinieren konnte:\n\n::: {style=\"padding-bottom: 20px;\"}\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nchart_ip = create_chart(df=df, x='Item Purchased', y='Purchase Amount (USD)',\n                        aggregation='sum', chart_type='scatter', sort_order='ascending', lower_threshold=8000, upper_threshold=10000)\n\n# Hinzufügen der waagrechten Linie für das untere Threshold\nlower_line = alt.Chart(pd.DataFrame({'y': [8000]})).mark_rule(\n    color='red').encode(y='y:Q')\n\n# Hinzufügen der waagrechten Linie für das obere Threshold\nupper_line = alt.Chart(pd.DataFrame({'y': [10000]})).mark_rule(\n    color='green').encode(y='y:Q')\n\n# Kombinieren von Chart, Linie und Text mit der layer-Methode\nfinal_chart = alt.layer(chart_ip, lower_line,\n                        upper_line).properties(width='container')\n\nfinal_chart\n```\n:::\n\n\n:::\n\nHier wurde beispielsweise noch eine Threshold Linie für zwei Werte erstellt die, dank des Altair Frameworks, ganz einfach mit `alt.layer()` kombiniert werden konnten, wobei hier die Chart aus der `create_chart()` Funktion immer die Basis darstellt.\n\nKombiniert mit der Quarto Markdown Syntax konnte ich somit recht einfach eine Slide in meiner Präsentation aufbauen. Dies war mir sehr wichtig, da bei der Homework dazu am Ende eine **800 Zeilen** Datei rauskam, die zunächst für mich persönlich sehr schwer zu überschauen war, ich aber auch da den funktionalen Ansatz genommen habe und somit die „Fehler“ dieses Mal ausbessern und mich wesentlich einfacher zurechtfinden konnte.\n\nSlides, bei der keine Graphen vorkommen wurden mit Quarto Markdown und HTML zusammengebaut.\n\n\n## Streamlit Aufbau\n\nGleichermaßen konnte ich das Dashboard mit der Funktion recht einfach aufbauen:\n\n::: {style=\"padding-bottom: 20px;\"}\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndf = f.get_df()\n\nst.sidebar.title('Filter')\n\n# inputs\nx_axis = st.sidebar.selectbox(\"Select X-axis:\", df.columns)\ny_axis_list = list(set(df.columns).difference([x_axis]))\n\ndefault_y_axis = 'Purchase Amount (USD)'\n\nif x_axis != default_y_axis:\n    y_axis_list.remove(default_y_axis)\n    y_axis_list.insert(0, default_y_axis)\n\ny_axis = st.sidebar.selectbox(\n    \"Select Y-axis:\", y_axis_list)\n\nchart_type = st.sidebar.radio(\n    \"Select Chart Type:\", ['bar', 'point', 'line', 'area', 'tick', 'scatter', 'boxplot'])\n\nsorting = None\naggregation = ''\nif df[y_axis].dtype in ['int64', 'float64']:\n    sorting = st.sidebar.radio(\"Select sorting order:\", [\n        None, 'ascending', 'descending'])\n\n    aggregation = st.sidebar.selectbox(\"Select Aggregation:\", [\n        'sum', 'average', 'count', 'min', 'max', 'median', 'stdev', 'variance'])\n\n# --------------------------------------------------------- PAGE\n\n# ...\n\ntry:\n    st.altair_chart(f.create_chart(df=df, x=x_axis, y=y_axis, aggregation=aggregation,\n                    chart_type=chart_type, sort_order=sorting), use_container_width=True)\nexcept Exception as e:\n    st.write(f'{e}')\n```\n:::\n\n\n:::\n\nIn diesem Beispiel musste ich lediglich durch Streamlit Widgets und vereinzelt weiterführender Logik die Parameter sammeln und in die `create_chart()` übergeben. Das dataframe und die Funktion werden von einer externen py-Datei geladen, in der alle Funktionen gesammelt sind. Dabei sind alle Funktionen gecached, damit die App insgesamt perfomanter läuft:\n\n::: {style=\"padding-bottom: 20px;\"}\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n@st.cache_data\ndef get_df():\n    # ...\n\n@st.cache_data\ndef create_chart(**kwargs):\n    # ...\n```\n:::\n\n\n:::\n\n\nDa die `create_chart()` Funktion ursprünglich für diesen Anwendungsfall gebaut war, lief das ohne großartige Probleme und ein Chart konnte somit sehr einfach zusammengestellt werden.\n\nDie Struktur meines Dashboard war so aufgebaut:\n\n::: {style=\"padding-bottom: 20px;\"}\n```{.python filename=\"app.py\"}\nimport streamlit as st\nfrom playground import playground\nfrom country_overview import country_overview\nfrom shopping_trends import shopping_trends\n\ndef main():\n    # Create a navigation bar to switch between pages\n    selected_page = st.sidebar.radio(\n        \"Select Page\", [\"Shopping Trends\", \"Country Overview\", \"Playground\"])\n\n    # Render the selected page\n    if selected_page == \"Country Overview\":\n        country_overview()\n    elif selected_page == \"Shopping Trends\":\n        shopping_trends()\n    elif selected_page == \"Playground\":\n        playground()\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n:::\n\nEine Ansicht war durch den Radio Input immer eine existierende Seite. Standardgemäß ist die Zusammenfassung der Präsentation ausgewählt und über die anderen Radio Buttons kann man ganz einfach auf die anderen Seiten des Dashboard navigieren. Dabei war jede Seite in einer Funktion verpackt, die hier je nach ausgewählten Radio ausgeführt und somit für den Nutzer gerendet wird.\n\n",
    "supporting": [
      "building-process_files"
    ],
    "filters": [],
    "includes": {}
  }
}